#### 題目：
var a = 1
function fn(){
  console.log(a)
  var a = 5
  console.log(a)
  a++
  var a 
  fn2()
  console.log(a)
  function fn2(){
    console.log(a)
    a = 20
    b = 100
  }
}
fn()
console.log(a)
a = 10
console.log(a)
console.log(b)

#### 輸出結果：
undefined
5
6
20
1
10
100

#### 說明：
由於 hoisting 的關係，我們可以將題目看成以下：
var a = 1
var b
function fn(){
  var a
  console.log(a)
  a = 5
  console.log(a)
  a++
  // var a 宣告有一個變數為 a，但變數 a 已經存在，此行宣告等於沒啥作用
  function fn2(){
    console.log(a)
    a = 20
    b = 100
  }
  fn2()
  console.log(a)
}
fn()
console.log(a)
a = 10
console.log(a)
console.log(b)

在利用 hoistng 改完題目的順序之後，我們在重新看回題目：
1. 首先，在 fn 這個 function 中，宣告了一個變數為 a，但此時還未賦值，提升只會提升宣告，而賦值這個動作並不會提升，所以只找到了一個變數宣告為 a，因此會回傳 undefined（有這個變數，但沒有值）
2. 之後，賦予了 a 值為 5，因此印出 5 這個值
  此時，a++，等於 a + 1 = 5 + 1 = 6，此時的 a 值為 6
3. var a 這行等於是宣告一個變數為 a，但此時變數 a 已存在，這行等於沒有作用，在修改題目這邊我就把它註解掉了
4. 再來，由於提升作用，會先宣告 fn2 這個函式，才會執行 fn2()，所以先把 function fn2 的宣告提升上來
  在這個函式執行當中，會先執行印出 a 的值，這時候在 fn2 裡面並沒有找到變數為 a 的值，所以往上一層找，找到變數為 a 的值 6
5. 在 fn2 的函式當中，重新將 a 賦值，此時的 a 值為 20；但並沒有變數 b，所以會先自動在全域當中宣告一個變數為 b，但在全域當中沒有賦值，是在 fn2 當中賦予其值為 100，但不管怎樣此時 b 的值為 100。
6. 執行 function fn 中的最後一行，印出目前的 a 的值，20
7. 執行完 fn 這個 function 之後，執行題目中的第十八行，印出 a 的值，由於此時是在全域當中，全域當中也有宣告一個變數為 a ，值為 1，印出 a 的值為 1。
8. 第十九行，在全域當中，又重新將變數 a 賦值，此時 a 的值為 10
9. 第二十行，印出 a 目前的值為 10
10. 執行第二十一行，印出 b 的值，此時我以為答案會是 undefined，因為 b 變數的值是在 function 裡面，又重新看回課程，發現原來在函式當中也可以改變全域變數的值，此時又重新思考回題目中第十八行的答案…
11. 思考過後，我想會不會是因為在函式當中也有宣告一個變數為 a，所以改變的都會是函式當中變數 a 的值；而不是改變到全域變數的值。但是如果是變數 b，由於在函式當中並沒有宣告，會自動在全域當中宣告一個變數為 b，所以函式當中原來可以改變到全域變數的值。
