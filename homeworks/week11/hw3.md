## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫
加密：一對一的關係，需要使用金鑰才能得到原本的密碼，具有可逆性。
雜湊：雜湊不能還原、不具有可逆性，因此攻擊者不能利用找到規律去破解，也屬於多對一的關係，有可能兩個不同密碼會對應到相同雜湊過後的值。

如果密碼直接明文存入資料庫中，那網站有管理權限的人都看得到會員的所有密碼，是非常不安全的，代表會員的身分隨時都有可能被盜用，那如果有駭客駭進了資料庫的主機，所有的會員個人資料、帳號密碼都會直接暴露在駭客面前，至少經過雜湊之後的密碼會是一串難以理解的值，難以讓駭客直接獲取會員的密碼。

## `include`、`require`、`include_once`、`require_once` 的差別
include在執行時，如果include進來的檔案發生錯誤的話，會顯示警告，不會立刻停止；而require 則是會顯示錯誤，立刻終止程式，不再往下執行。
使用 include 跟 include_once 都只會試圖匯入該檔案，使用 include 時，即使該檔案沒有被找到，程式依然會執行；但當我們絕對需要匯入一個檔案時，則需要使用 require。
require 適合用來引入靜態的內容，例如版權宣告，而 include 則適合用來引入動態的程式碼，程式內容會依其他程式碼而變動。

而後面加入 once 都是避免被重複引入，在執行之前會先檢查要匯入的檔案是不是已經在該程序中的其它地方被匯入過了，如果有的話就不會再次重複導入該檔案，如果有寫入 once 的話，重複的檔案就會被忽略，不然重複引入會引發錯誤，沒有加上 once 的執行效率會高於加上的，因為後者會檢查有沒有匯入過此檔案，但加上 once 可以避免函式重複定義、變數重新賦值，一般來說還是建議使用後者。

## 請說明 SQL Injection 的攻擊原理以及防範方法
在輸入的字串之中夾帶 SQL 指令，這些被夾帶進去的惡意指令，會被資料庫伺服器誤認為是正常的SQL指令而執行，可能造成資料庫中的資料外洩、系統管理員帳號被竄改、修改資料庫資料，在網頁加入惡意連結、惡意代碼。

防範方法：
1. 採用參數化查詢語法
在設計應用程式時，完全使用參數化查詢（Parameterized Query）來設計資料存取功能。
在撰寫 SQL 語法時，使用者輸入的變數不是直接動態結合到 SQL 查詢語法，而是通過參數來傳遞這個變數的話，就可以有效的避免 SQL Injection 資料隱碼攻擊。
2. 加入跳脫字元的功能，將單引號字元轉換成雙引號，還有將單引號加上 /。

## 請說明 XSS 的攻擊原理以及防範方法
XSS(Cross-Site Scripting)跨網站指令碼攻擊，在使用者讀取網站的時候，載入並執行攻擊者提供的程式碼，通常透過 HTML/JavaScript，在使用者端的瀏覽器執行，可用來竊取用戶的 cookie，甚至冒用使用者的身分。

目前 XSS 攻擊的種類大致可以分成以下幾種類型：
1. Stored XSS (儲存型)
會被保存在伺服器資料庫中的 JavaScript 代碼引起的攻擊，常見於論壇文章、留言板。
使用者可以任意輸入內容，若沒有確實檢查，標籤內容會被當成正常的 JavaScript 執行。
2. Reflected XSS (反射型)
不會儲存在資料庫中，而是由後端直接嵌入由前端使用者所傳送過來的內容，最常見是以 GET 方法傳送資料給伺服器時，伺服器若沒有檢查就將內容反映到網頁上所產生的漏洞。
3. DOM-Based XSS (基於 DOM 的類型)
DOM(Document Object Model)，用以描述 HTML 文件的表示法，讓我們可以不必透過伺服器使用 JavaScript 動態產生完整的網頁。因此，DOM-Based XSS 是指網頁上的 JavaScript 在執行過程中，沒有詳細檢查資料使得操作 DOM 的過程帶入了惡意指令。通常需要搭配前兩個手法，讓內容保存在伺服器資料庫中，或是以反射型製造出內容，再藉由 JavaScript 動態產生有效的 DOM 物件來運行惡意代碼。
很多程式語言都有提供以透過過濾特殊字元來防範。

在以上所說的攻擊方法中，前兩者可以利用替代字元杜絕，除了必要的 HTML 代碼，任何允許使用者輸入的內容都要檢查，刪除所有可能執行代碼的字串。
第三種需要由前端防範，選擇正確的方法、屬性來操作 DOM，避免被插入惡意代碼執行。

## 請說明 CSRF 的攻擊原理以及防範方法
CSRF(Cross-Site Request Forgery)跨站請求偽造，是一種 Web 上的攻擊手法，欺騙使用者的瀏覽器去存取一個自己曾經認證過的網站並執行一些操作，被存取的網站會認為是真正的使用者操作而去執行，利用了使用者身分驗證的一個漏洞，只能保證請求發自使用者的瀏覽器，卻不能保證請求本身是使用者自願發出的。跟 XSS 相比，XSS 利用的是使用者對指定網站的信任，CSRF 利用的是網站對使用者網頁瀏覽器的信任。

如何防禦？
* Server 的防禦，擋掉從別的 domain 發出來的請求。
* 檢查 Referer
request 的 header 裡面，會帶一個欄位叫做 referer，代表這個 request 是從哪個地方過來的，可以檢查這個欄位看是不是合法的 domain。需要注意的是，有些瀏覽器可能不會帶 referer，又或是有些使用者可能會關閉自動帶入 referer 的功能，這時候 server 可能會拒絕由真正使用者發出的請求。還有判定是否合法 domain 的程式碼必須要保證沒有任何 bug。
* 圖形驗證碼、簡訊驗證碼等等
* 加上 CSRF token
可以在 form 裡面加上一個 hidden 的欄位，叫做 csrftoken，值由 server 隨機產生，並且存在 server 的 session 之中。
server 可以利用此，比對表單中的與 session 內儲存的值是否一樣，是的話就代表是由使用者本人發出的請求，這個 csrftoken 由 server 產生，並且每一段不同的 session 就應該要更換一次。
* Double Submit Cookie
由 server 產生一組隨機的 token，並加在 form 上，不用把這個值寫在 session，同時也讓 client 端設定一個名叫 csrftoken 的 cookie，存同一組 token。利用區別出 request 是否從同樣的 domain 發出，確認是否為使用者本人的方法。
* 瀏覽器本身的防禦
目前只有 Chrome 支援這個新的特性。當加上 SameSite 這個關鍵字之後，就代表這個 cookie 只允許 same site 使用，不應該在任何的 cross site request 被加上去，只要是瀏覽器驗證不是在同一個 site 底下發出的 request，全部都不會帶上這個 cookie。